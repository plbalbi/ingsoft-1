Object subclass: #ClassMapping	instanceVariableNames: 'mappedClass mappings tableName'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-PersistanceModel'!!ClassMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 11/1/2016 00:40'!map: anObject using: aDataBaseSession	| record |	self toDo: 'se puede optimizar usando array para registros y guardando definicion de tabla una vez'.	record := Dictionary new.		self mapIdOf: anObject into: record using: aDataBaseSession.	self mapEmbededOf: anObject into: record.	"agrego aca el registro y no luego de mapear el id para que lo agrege completo. Lo agrego antes de mapear las rel one to many 	porque si usuara una db de verdad habria foreign key constrain"	aDataBaseSession add: record on: self tableName.	self mapOneToManyRelationshipsOf: anObject using: aDataBaseSession! !!ClassMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 11/1/2016 00:42'!unmap: aRecord using: aDataBaseSession	| unMappedObject |	unMappedObject := mappedClass basicNew.	self unmapIdOf: aRecord into: unMappedObject.	self unmap: aRecord into: unMappedObject using: aDataBaseSession.	^ unMappedObject! !!ClassMapping methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 00:40'!mapOneToManyRelationshipsOf: anObject using: aDataBaseSession	mappings do: [ :aMapping | aMapping mapOneToManyRelationshipsOf: anObject using: aDataBaseSession ]! !!ClassMapping methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 00:43'!unmap: aRecord into: unMappedObject using: aDataBaseSession	mappings do: [ :aMapping | aMapping unmap: aRecord into: unMappedObject using: aDataBaseSession ]! !!ClassMapping methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 00:40'!mapEmbededOf: anObject into: record	mappings do: [ :aMapping | aMapping embeded: anObject into: record ]! !!ClassMapping methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 00:43'!unmapIdOf: aRecord into: unMappedObject	unMappedObject instVarNamed: #id put: (aRecord at: #id)! !!ClassMapping methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 00:40'!mapIdOf: anObject into: record using: aDataBaseSession	| newId |	newId := aDataBaseSession newIdFor: anObject.	anObject instVarNamed: #id put: newId.	record at: #id put: newId! !!ClassMapping methodsFor: 'table' stamp: 'HernanWilkinson 10/31/2016 23:25'!tableName		^tableName ! !!ClassMapping methodsFor: 'initialization' stamp: 'HernanWilkinson 10/31/2016 23:25'!initializeFor: aClass into: aTableName mappingAll: aCollectionOfMappings	mappedClass := aClass.	tableName := aTableName.	mappings := aCollectionOfMappings ! !!ClassMapping methodsFor: 'testing' stamp: 'HernanWilkinson 10/31/2016 23:02'!isFor: aClass	^mappedClass = aClass! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ClassMapping class	instanceVariableNames: ''!!ClassMapping class methodsFor: 'assertions' stamp: 'HernanWilkinson 10/31/2016 19:26'!assertValidMappings: aCollectionOfMappings for: aClass 	self toDo: 'Lo mejor seria recolectar todos los erroes de mapeo y no parar en el primero'.	aCollectionOfMappings do: [ :aMapping | aMapping assertIsValidFor: aClass ]	! !!ClassMapping class methodsFor: 'assertions' stamp: 'HernanWilkinson 10/31/2016 21:15'!assertHasIdInstanceVariable: aClass 		(aClass hasInstVarNamed: #id) ifFalse: [ self error: ('<1s> has no id instance variable' expandMacrosWith: aClass name) ]! !!ClassMapping class methodsFor: 'assertions' stamp: 'HernanWilkinson 10/31/2016 23:41'!assertValidTableName: aTableName	aTableName trimBoth isEmpty ifTrue: [ self error: 'Table name can not be empty' ]! !!ClassMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 11/1/2016 00:44'!defaultTableNameFor: aClass		^aClass name asString! !!ClassMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:23'!withDefaultTableNameFor: aClass mappingAll: aCollectionOfMappings	^self for: aClass into: (self defaultTableNameFor: aClass) mappingAll: aCollectionOfMappings		! !!ClassMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:24'!for: aClass into: aTableName mappingAll: aCollectionOfMappings	self assertValidTableName: aTableName.	self assertHasIdInstanceVariable: aClass.	self assertValidMappings: aCollectionOfMappings for: aClass.		^self new initializeFor: aClass into: aTableName mappingAll: aCollectionOfMappings		! !Object subclass: #DataBaseSession	instanceVariableNames: 'configuration tables id cache'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-PersistanceModel'!!DataBaseSession methodsFor: 'selecting - private' stamp: 'HernanWilkinson 11/1/2016 01:28'!addInto: selected theOnesThatHold: aCondition unmapping: record with: mapper	| recordId aClassInstance |	recordId := self recordId: record.	aClassInstance := cache at: recordId ifAbsent: [ mapper unmap: record using: self ].	(aCondition value: aClassInstance) ifTrue: [ 		self addToCache: aClassInstance.		selected add: aClassInstance ].		^ selected! !!DataBaseSession methodsFor: 'persistance' stamp: 'HernanWilkinson 11/1/2016 01:28'!persist: anObject	| mapper |		self assertInTransaction.	self delay.		mapper := self mapperFor: anObject class.	mapper map: anObject using: self.		self addToCache: anObject ! !!DataBaseSession methodsFor: 'id' stamp: 'HernanWilkinson 11/1/2016 01:04'!recordId: aRecord	^aRecord at: #id! !!DataBaseSession methodsFor: 'id' stamp: 'HernanWilkinson 10/28/2016 16:35'!newIdFor: anObject	id := id + 1.	^id! !!DataBaseSession methodsFor: 'id' stamp: 'HernanWilkinson 11/1/2016 01:00'!idOf: anObject	^anObject instVarNamed: #id! !!DataBaseSession methodsFor: 'persistence - private' stamp: 'HernanWilkinson 10/28/2016 16:35'!defineIdOf: anObject	anObject instVarNamed: 'id' put: (self newIdFor: anObject).! !!DataBaseSession methodsFor: 'persistence - private' stamp: 'HernanWilkinson 10/28/2016 16:41'!delay	(Delay forMilliseconds: 100) wait! !!DataBaseSession methodsFor: 'transaction management' stamp: 'HernanWilkinson 10/31/2016 22:55'!assertNotInTransasction		cache notNil ifTrue: [ self error: 'There is an open transaction already' ]! !!DataBaseSession methodsFor: 'transaction management' stamp: 'HernanWilkinson 10/31/2016 22:55'!assertInTransaction		cache isNil ifTrue: [ self error: 'There is no transaction currently' ]! !!DataBaseSession methodsFor: 'transaction management' stamp: 'HernanWilkinson 10/31/2016 22:57'!beginTransaction	self assertIsOpen.	self assertNotInTransasction.		cache := WeakKeyDictionary new.	! !!DataBaseSession methodsFor: 'transaction management' stamp: 'HernanWilkinson 10/31/2016 22:57'!commit		self assertInTransaction.		cache := nil! !!DataBaseSession methodsFor: 'open/close' stamp: 'HernanWilkinson 10/31/2016 18:37'!assertIsClose		tables isNil ifFalse: [ self error: 'Session must be close' ]! !!DataBaseSession methodsFor: 'open/close' stamp: 'HernanWilkinson 10/31/2016 18:36'!open	self assertIsClose.		tables := Dictionary new.	! !!DataBaseSession methodsFor: 'open/close' stamp: 'HernanWilkinson 10/31/2016 22:14'!close	self assertIsOpen.		tables := nil! !!DataBaseSession methodsFor: 'open/close' stamp: 'HernanWilkinson 10/31/2016 18:36'!assertIsOpen		tables isNil ifTrue: [ self error: 'Session must be open to colaborate with it' ]! !!DataBaseSession methodsFor: 'tables - private' stamp: 'HernanWilkinson 11/1/2016 00:48'!tableNamed: aTableName	^ tables at: aTableName ifAbsentPut: [ Dictionary new ]! !!DataBaseSession methodsFor: 'tables - private' stamp: 'HernanWilkinson 11/1/2016 01:12'!relationTableFor: anOwnerClass relatedTo: aRelatedClass	| relationTableName table |	relationTableName := self relationTableNameOwnedBy: anOwnerClass relatedTo: aRelatedClass.	table := self tableNamed: relationTableName.		^ table! !!DataBaseSession methodsFor: 'tables - private' stamp: 'HernanWilkinson 11/1/2016 01:12'!relationTableNameOwnedBy: anOwnerClass relatedTo: aRelatedClass	| ownerClassMapper relatedClassMapper |		ownerClassMapper := self mapperFor: anOwnerClass.	relatedClassMapper := self mapperFor: aRelatedClass.		^ownerClassMapper tableName,'_', relatedClassMapper tableName asPlural.! !!DataBaseSession methodsFor: 'initialization' stamp: 'HernanWilkinson 10/31/2016 22:55'!initializeFor: aConfiguration	configuration := aConfiguration.	id := 0.	tables := nil.	cache := nil.! !!DataBaseSession methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 01:14'!mapperFor: aClass	self toDo: 'se puede mejorar performanco usando un dictionary'.	^configuration		detect: [ :aClassMapper | aClassMapper isFor: aClass ] 		ifNone: [ self error: ('There is no mapper for <1s>' expandMacrosWith: aClass name) ]! !!DataBaseSession methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 01:16'!unmapRecordIdentifiedAs: anId ofType: aClass	| record table mapper |	mapper := self mapperFor: aClass.	table := self tableNamed: mapper tableName.	record := table at: id ifAbsent: [ self error: ('Object identified as <1s> does not exist' expandMacrosWith: anId printString) ].		^ mapper unmap: record using: self! !!DataBaseSession methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 01:15'!relatedOfType: aRelatedClass for: anOwner	| table relatedIds |		table := self relationTableFor: anOwner class relatedTo: aRelatedClass.	relatedIds := table at: (self idOf: anOwner) ifAbsent: [ ^#() ].		^relatedIds collect: [ :aRelatedId | self objectIdentifiedAs: aRelatedId ofType: aRelatedClass ]		! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:03'!add: aRecord on: aTableName	| table existingRecord |	table := self tableNamed: aTableName.	existingRecord := table at: (self recordId: aRecord) ifAbsentPut: [ aRecord ].	existingRecord == aRecord ifFalse: [ self error: 'Duplicated primary key' ]! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:05'!assertRelationOwnedBy: anOwner isUniqueFor: aRelated identifiedAs: relatedId in: relatedIds	(relatedIds includes: relatedId) ifTrue: [ self signalRelationAlreadyExistBetween: anOwner and: aRelated ]! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:06'!relatedIdOwnedBy: anOwner on: table	^ table at: (self idOf: anOwner) ifAbsentPut: [ Set new ]! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:03'!addRelated: aRelated ownedBy: anOwner	| relatedIds relatedId |	relatedIds := self relatedIdsOwnedBy: anOwner forType: aRelated class.	relatedId := aRelated instVarNamed: #id.	self assertRelationOwnedBy: anOwner isUniqueFor: aRelated identifiedAs: relatedId in: relatedIds.		relatedIds add: relatedId! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:10'!relatedIdsOwnedBy: anOwner forType: aRelatedClass	| relatedIds table |	table := self relationTableFor: anOwner class relatedTo: aRelatedClass.	relatedIds := self relatedIdOwnedBy: anOwner on: table.		^ relatedIds! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:00'!signalRelationAlreadyExistBetween: anOwner and: aRelated 	self error: ('Relation between id <1s> of type <2s> and id <3s> of type <4s> already exist'		expandMacrosWith: (self idOf: anOwner) printString		with: anOwner class name		with: (self idOf: aRelated) printString		with: aRelated class name)! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:27'!addToCache: anObject 	cache at: (self idOf: anObject) put: anObject ! !!DataBaseSession methodsFor: 'selecting' stamp: 'HernanWilkinson 10/31/2016 22:17'!selectAllOfType: aClass 		^self select: [ :anObject | true ] ofType: aClass! !!DataBaseSession methodsFor: 'selecting' stamp: 'HernanWilkinson 11/1/2016 01:15'!objectIdentifiedAs: anId ofType: aClass	self assertInTransaction.	self delay.		^ cache at: anId ifAbsentPut: [ self unmapRecordIdentifiedAs: anId ofType: aClass ]! !!DataBaseSession methodsFor: 'selecting' stamp: 'HernanWilkinson 11/1/2016 01:26'!select: aCondition ofType: aClass	| mapper table |	self assertInTransaction.	self delay.		mapper := self mapperFor: aClass.	table := tables at: mapper tableName ifAbsent: [ ^ #() ].		^ table inject: OrderedCollection new into: [ :selected :record | self addInto: selected theOnesThatHold: aCondition unmapping: record with: mapper ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DataBaseSession class	instanceVariableNames: ''!!DataBaseSession class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/28/2016 13:07'!for: aConfiguration	^self new initializeFor: aConfiguration! !Object subclass: #Mapping	instanceVariableNames: 'instanceVariableName'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-PersistanceModel'!!Mapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 23:26'!embeded: anObject into: aRecord	self subclassResponsibility! !!Mapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 23:26'!unmap: aRecord into: anObject using: aDataBaseSession	self subclassResponsibility! !!Mapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 23:26'!mapOneToManyRelationshipsOf: anObject using: aDataBaseSession	self subclassResponsibility! !!Mapping methodsFor: 'assertions' stamp: 'HernanWilkinson 11/1/2016 01:31'!assertIsValidFor: aClass 	(aClass hasInstVarNamed: instanceVariableName) ifFalse: [ 		self error: ('Invalid mapping for <1s> in class <2s>' expandMacrosWith: instanceVariableName with: aClass name) ] ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Mapping class	instanceVariableNames: ''!!Mapping class methodsFor: 'assertions' stamp: 'HernanWilkinson 10/31/2016 23:41'!assertValidFieldName: aFieldName	aFieldName trimBoth isEmpty ifTrue: [ self error: 'Field name can not be empty' ]! !!Mapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 11/1/2016 01:32'!defaultFieldNameFor: anInstanceVariableName	^anInstanceVariableName asString! !Mapping subclass: #EmbededMapping	instanceVariableNames: 'fieldName'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-PersistanceModel'!!EmbededMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 23:31'!embeded: anObject into: aRecord	aRecord at: fieldName put: (anObject instVarNamed: instanceVariableName) ! !!EmbededMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 23:31'!unmap: aRecord into: anObject using: aDataBaseSession 	anObject instVarNamed: instanceVariableName put: (aRecord at: fieldName)! !!EmbededMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 21:23'!mapOneToManyRelationshipsOf: anObject using: aDataBaseSession 		! !!EmbededMapping methodsFor: 'initialization' stamp: 'HernanWilkinson 10/31/2016 23:30'!initializeFor: anInstanceVariableName into: aFieldName	instanceVariableName := anInstanceVariableName.	fieldName := aFieldName ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!EmbededMapping class	instanceVariableNames: ''!!EmbededMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:29'!withDefaultFieldNameFor: anInstanceVariableName	^self for: anInstanceVariableName into: (self defaultFieldNameFor: anInstanceVariableName)! !!EmbededMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:30'!for: anInstanceVariableName into: aFieldName	^self new initializeFor: anInstanceVariableName into: aFieldName ! !Mapping subclass: #OneToManyMapping	instanceVariableNames: 'relatedType fieldName'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-PersistanceModel'!!OneToManyMapping methodsFor: 'initialization' stamp: 'HernanWilkinson 10/31/2016 23:34'!initializeFor: anInstanceVariableName into: aFieldName ofType: aClass	instanceVariableName := anInstanceVariableName.	fieldName := aFieldName.	relatedType := aClass ! !!OneToManyMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 21:16'!embeded: anObject into: aRecord	! !!OneToManyMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 11/1/2016 01:37'!unmap: aRecord into: anObject using: aDataBaseSession	| newCollection related |	related := aDataBaseSession relatedOfType: relatedType for: anObject.	newCollection := self createRelationCollectionOn: aDataBaseSession ownedBy: anObject.	newCollection addAllNotPersisting: related.	anObject instVarNamed: instanceVariableName put: newCollection! !!OneToManyMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 11/1/2016 01:35'!createRelationCollectionOn: aDataBaseSession ownedBy: anObject	^ OneToManySet on: aDataBaseSession ownedBy: anObject! !!OneToManyMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 11/1/2016 01:37'!mapOneToManyRelationshipsOf: anObject using: aDataBaseSession	| oldCollection newCollection |	newCollection := self createRelationCollectionOn: aDataBaseSession ownedBy: anObject.	oldCollection := anObject instVarNamed: instanceVariableName.		newCollection addAll: oldCollection.	anObject instVarNamed: instanceVariableName put: newCollection! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!OneToManyMapping class	instanceVariableNames: ''!!OneToManyMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:40'!for: anInstanceVariableName into: aFieldName ofType: aClass	self assertValidFieldName: aFieldName.		^self new initializeFor: anInstanceVariableName into: aFieldName ofType: aClass! !!OneToManyMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:32'!withDefaultFieldNameFor: anInstanceVariableName ofType: aClass	^self for: anInstanceVariableName into: (self defaultFieldNameFor: anInstanceVariableName) ofType: aClass! !Set subclass: #OneToManySet	instanceVariableNames: 'session owner'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-PersistanceModel'!!OneToManySet methodsFor: 'removing' stamp: 'HernanWilkinson 10/31/2016 21:35'!remove: anObject ifAbsent: anAbsentBlock	self shouldBeImplemented ! !!OneToManySet methodsFor: 'adding' stamp: 'HernanWilkinson 11/1/2016 00:03'!addAllNotPersisting: aCollection 		^aCollection do: [ :anObjectToAdd | super add: anObjectToAdd ]! !!OneToManySet methodsFor: 'adding' stamp: 'HernanWilkinson 11/1/2016 00:11'!add: anObject	session persist: anObject.	session addRelated: anObject ownedBy: owner.		super add: anObject.! !!OneToManySet methodsFor: 'initialization' stamp: 'HernanWilkinson 11/1/2016 00:11'!initializeOn: aDataBaseSession ownedBy: anOwner		session := aDataBaseSession.	owner := anOwner ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!OneToManySet class	instanceVariableNames: ''!!OneToManySet class methodsFor: 'instance creation' stamp: 'HernanWilkinson 11/1/2016 00:11'!on: aDataBaseSession ownedBy: anOwner		^self new initializeOn: aDataBaseSession ownedBy: anOwner ! !Object subclass: #Address	instanceVariableNames: 'id streetName streetNumber town zipCode province'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!Address methodsFor: 'province' stamp: 'HernanWilkinson 10/28/2016 16:11'!province	^province! !!Address methodsFor: 'province' stamp: 'HernanWilkinson 10/28/2016 16:08'!province: aProvince 	province := aProvince	! !!Address methodsFor: 'lookup' stamp: 'HernanWilkinson 11/1/2016 10:06'!isAt: aStreetName	^streetName = aStreetName ! !!Address methodsFor: 'town' stamp: 'HernanWilkinson 10/28/2016 16:12'!town	^town! !!Address methodsFor: 'town' stamp: 'HernanWilkinson 10/28/2016 16:07'!town: aTown 	town := aTown! !!Address methodsFor: 'zip code' stamp: 'HernanWilkinson 10/28/2016 16:08'!zipCode: aZipCode 	zipCode := aZipCode! !!Address methodsFor: 'zip code' stamp: 'HernanWilkinson 10/28/2016 16:13'!zipCode	^zipCode! !!Address methodsFor: 'street' stamp: 'HernanWilkinson 10/28/2016 16:12'!streetName	^streetName ! !!Address methodsFor: 'street' stamp: 'HernanWilkinson 10/28/2016 13:27'!streetNumber: aStreetNumber 	streetNumber := aStreetNumber ! !!Address methodsFor: 'street' stamp: 'HernanWilkinson 10/28/2016 16:12'!streetNumber	^streetNumber ! !!Address methodsFor: 'street' stamp: 'HernanWilkinson 10/28/2016 13:27'!streetName: aStreetName 	streetName := aStreetName ! !TestCase subclass: #CustomerImportTest	instanceVariableNames: 'importer system'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!CustomerImportTest methodsFor: 'importing' stamp: 'PauloOlveira 7/2/2018 08:07'!customerIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber	^ system		customerIdentifiedAs: anIdentifycationType		numbered: anIdentificationNumber! !!CustomerImportTest methodsFor: 'importing' stamp: 'PauloOlveira 7/2/2018 08:07'!importedCustomersCount	^system allCustomers size! !!CustomerImportTest methodsFor: 'setup-teardown' stamp: 'PauloOlveira 7/2/2018 08:07'!setUp	system := (Environment currentFor: self) createCustomerSystem.	system start.	system beginTransaction! !!CustomerImportTest methodsFor: 'setup-teardown' stamp: 'PauloOlveira 7/2/2018 08:07'!tearDown	system commit.	system close! !!CustomerImportTest methodsFor: 'test data' stamp: 'PauloOlveira 6/25/2018 16:45'!nonNumericAddressRecordInput	^ReadStream on: 'C,Pepe,Sanchez,D,22333444A,San Martin,Numero1,Olivos,Numero2,BsAs'! !!CustomerImportTest methodsFor: 'test data' stamp: 'Pablo 6/21/2018 20:46'!invalidAddressRecordInput	^ReadStream on: 'A,calle falsa,1'! !!CustomerImportTest methodsFor: 'test data' stamp: 'Pablo 6/21/2018 20:31'!emptyInput	^ReadStream on: ''.! !!CustomerImportTest methodsFor: 'test data' stamp: 'Pablo 6/21/2018 20:38'!invalidCustomerRecordInput	^ReadStream on: 'C,Pepe,Sanchez'! !!CustomerImportTest methodsFor: 'test data' stamp: 'Pablo 6/21/2018 21:05'!firstRecordIsAddressInput	^ReadStream on: 'A,San Martin,3322,Olivos,1636,BsAs'! !!CustomerImportTest methodsFor: 'test data' stamp: 'Pablo 6/24/2018 16:45'!firstSavedButSecondFailInput	^ ReadStream on:'C,Pepe,Sanchez,D,22333444A,San Martin,3322,Olivos,1636,BsAsA,Maipu,888,Florida,1122,Buenos AiresJ'! !!CustomerImportTest methodsFor: 'test data' stamp: 'HernanWilkinson 11/1/2016 15:17'!validTestData	^ ReadStream on:'C,Pepe,Sanchez,D,22333444A,San Martin,3322,Olivos,1636,BsAsA,Maipu,888,Florida,1122,Buenos AiresC,Juan,Perez,C,23-25666777-9A,Alem,1122,CABA,1001,CABA'! !!CustomerImportTest methodsFor: 'test data' stamp: 'Pablo 6/21/2018 20:22'!invalidTypeInput	^ReadStream on: 	'J'! !!CustomerImportTest methodsFor: 'asserting' stamp: 'HernanWilkinson 11/1/2016 15:16'!assertPepeSanchezWasImportedCorrectly	| customer idType idNumber |	idType := 'D'.	idNumber := '22333444'.	customer := self customerIdentifiedAs: idType numbered: idNumber.		self assert: customer isNamed: 'Pepe' lastName: 'Sanchez' identfiedAs: idType withNumber: idNumber andNumberOfAddresses: 2.	self assert: customer hasAddressAt: 'San Martin' number: 3322 in: 'Olivos' zipCode: 1636 province: 'BsAs'.	self assert: customer hasAddressAt: 'Maipu' number: 888 in: 'Florida' zipCode: 1122 province: 'Buenos Aires'! !!CustomerImportTest methodsFor: 'asserting' stamp: 'HernanWilkinson 11/1/2016 15:14'!assertJuanPerezWasImportedCorrectly		| customer idType idNumber |		idType := 'C'.	idNumber := '23-25666777-9'.	customer := self customerIdentifiedAs: idType numbered: idNumber.		self assert: customer isNamed: 'Juan' lastName: 'Perez' identfiedAs: idType withNumber: idNumber andNumberOfAddresses: 1.	self assert: customer hasAddressAt: 'Alem' number: 1122 in: 'CABA' zipCode: 1001 province: 'CABA'.	! !!CustomerImportTest methodsFor: 'asserting' stamp: 'HernanWilkinson 11/1/2016 11:00'!assert: customer hasAddressAt: streetName number: streetNumber in: town zipCode: zipCode province: province	| address |		address := customer addressAt: streetName ifNone: [ self fail ].	self assert: address streetName equals: streetName.	self assert: address streetNumber equals: streetNumber.	self assert: address town equals: town.	self assert: address zipCode equals: zipCode.	self assert: address province equals: province.	! !!CustomerImportTest methodsFor: 'asserting' stamp: 'HernanWilkinson 11/1/2016 10:56'!assert: customer isNamed: firstName lastName: lastName identfiedAs: idType withNumber: idNumber andNumberOfAddresses: addressesSize	self assert: customer firstName equals: firstName.	self assert: customer lastName equals: lastName.	self assert: customer identificationType equals: idType.	self assert: customer identificationNumber equals: idNumber.	self assert: customer numberOfAddresses equals: addressesSize .! !!CustomerImportTest methodsFor: 'asserting' stamp: 'Pablo 6/27/2018 23:55'!assertImportedCustomersSizeIsCorrect	self assert: self importedCustomersCount equals: 2! !!CustomerImportTest methodsFor: 'asserting' stamp: 'PauloOlveira 7/2/2018 08:07'!assertNothingWasImported	self assert: system allCustomers isEmpty.	^ self assert:		system allAddresses isEmpty! !!CustomerImportTest methodsFor: 'testing' stamp: 'PauloOlveira 7/2/2018 08:07'!test08FailWhenNumericFieldDataIsNotNumericInAddressRecord	self		should: [ (CustomerImporter from: self nonNumericAddressRecordInput   in: system) import ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :error | 			self				assert: error messageText				equals: CustomerImporter nonNumericAddressRecordFieldsError]! !!CustomerImportTest methodsFor: 'testing' stamp: 'PauloOlveira 7/2/2018 08:07'!test04FailWhenNotEnoughFieldsInCustomerRecord	self		should: [ (CustomerImporter from: self invalidCustomerRecordInput in: system) import ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :error | 			self				assert: error messageText				equals: CustomerImporter missingCustomerRecordFieldsError.				self assertNothingWasImported ]! !!CustomerImportTest methodsFor: 'testing' stamp: 'PauloOlveira 7/2/2018 08:07'!test06FailWhenSavingAddressToNonExistingCustomer	self		should: [ (CustomerImporter from: self firstRecordIsAddressInput in: system) import ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :error | 			self				assert: error messageText				equals: CustomerImporter cannotSaveAddressWithoutACustomerError.				self assertNothingWasImported ]! !!CustomerImportTest methodsFor: 'testing' stamp: 'PauloOlveira 7/2/2018 08:07'!test03FailWhenFieldIsNeitherACustomerNorAnAddress	self		should: [ (CustomerImporter from: self invalidTypeInput in: system) import ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :error | 			self				assert: error messageText				equals: CustomerImporter invalidRecordTypeError.				self assertNothingWasImported ]! !!CustomerImportTest methodsFor: 'testing' stamp: 'PauloOlveira 7/2/2018 08:07'!test05FailWhenNotEnoughFieldsInAddressRecord	self		should: [ (CustomerImporter from: self invalidAddressRecordInput in: system) import ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :error | 			self				assert: error messageText				equals: CustomerImporter missingAddressRecordFieldsError.				self assertNothingWasImported ]! !!CustomerImportTest methodsFor: 'testing' stamp: 'PauloOlveira 7/2/2018 08:07'!test02ImportingStreamWithNoDataGivesDatabaseEmpty		(CustomerImporter from: self emptyInput  in: system) import.		self assertNothingWasImported.! !!CustomerImportTest methodsFor: 'testing' stamp: 'PauloOlveira 7/2/2018 08:07'!test07ImporterSavesOneCustomerButFailsInSecondOne	"The error being tested is invalidRecord type, but it could be any other one"	self		should: [ (CustomerImporter				from: self firstSavedButSecondFailInput				in: system) import ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :error | 			self				assert: error messageText				equals: CustomerImporter invalidRecordTypeError.			self assert: self importedCustomersCount equals: 1.			self assertPepeSanchezWasImportedCorrectly ]! !!CustomerImportTest methodsFor: 'testing' stamp: 'PauloOlveira 7/2/2018 08:07'!test01ImportCustomers		(CustomerImporter from: self validTestData in: system) import.		self assertImportedCustomersSizeIsCorrect.	self assertPepeSanchezWasImportedCorrectly.	self assertJuanPerezWasImportedCorrectly! !Object subclass: #CustomerSystem	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!CustomerSystem methodsFor: 'accessing' stamp: 'PauloOlveira 6/27/2018 00:33'!allAddresses
	self subclassResponsibility! !!CustomerSystem methodsFor: 'accessing' stamp: 'PauloOlveira 6/27/2018 00:33'!customerIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber
	self subclassResponsibility! !!CustomerSystem methodsFor: 'accessing' stamp: 'PauloOlveira 6/27/2018 00:33'!allCustomers
	self subclassResponsibility! !!CustomerSystem methodsFor: 'session handling' stamp: 'Pablo 6/28/2018 01:02'!commit	self subclassResponsibility ! !!CustomerSystem methodsFor: 'session handling' stamp: 'Pablo 6/27/2018 23:51'!start	self subclassResponsibility ! !!CustomerSystem methodsFor: 'session handling' stamp: 'PauloOlveira 6/27/2018 00:33'!beginTransaction
	self subclassResponsibility! !!CustomerSystem methodsFor: 'session handling' stamp: 'Pablo 6/28/2018 01:02'!close	self subclassResponsibility ! !!CustomerSystem methodsFor: 'persistance' stamp: 'Pablo 6/27/2018 23:51'!persist: aCustomer 	self subclassResponsibility ! !Object subclass: #Environment	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Environment class	instanceVariableNames: ''!!Environment class methodsFor: 'as yet unclassified' stamp: 'PauloOlveira 7/2/2018 16:39'!createSupplierSystem	self subclassResponsibility ! !!Environment class methodsFor: 'system creation' stamp: 'Pablo 6/28/2018 00:04'!createCustomerSystem	self subclassResponsibility ! !!Environment class methodsFor: 'selection' stamp: 'Pablo 6/28/2018 00:22'!current	^self subclasses detect: [:anEnviroment | anEnviroment isCurrent ] ifNone: [ self error: 'No appropiate environment found!!' ]! !!Environment class methodsFor: 'selection' stamp: 'Pablo 7/2/2018 19:01'!currentFor: anEnvironmentRequester 	(anEnvironmentRequester isKindOf: TestCase) 		ifTrue: [ ^TestEnvironment ]		ifFalse: [ ^IntegrationEnvironment  ] ! !Object subclass: #Importer	instanceVariableNames: 'line record inputStream importSystem'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!Importer methodsFor: 'initialization' stamp: 'Pablo 7/2/2018 10:35'!initializeWith: aSession importingFrom: aStream	importSystem := aSession.	inputStream := aStream. 	! !!Importer methodsFor: 'parsing' stamp: 'Pablo 7/2/2018 10:30'!nextLine	line := inputStream nextLine! !!Importer methodsFor: 'importing' stamp: 'Pablo 7/2/2018 10:31'!importRecord	self subclassResponsibility ! !!Importer methodsFor: 'importing' stamp: 'Pablo 7/2/2018 10:28'!import	self nextLine.	[ line notNil ]		whileTrue: [ 			self importRecord.			self nextLine ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Importer class	instanceVariableNames: ''!!Importer class methodsFor: 'error messages' stamp: 'Pablo 7/2/2018 10:33'!invalidRecordTypeError	^'Unknown record type encountered'! !!Importer class methodsFor: 'instance creation' stamp: 'Pablo 7/2/2018 10:32'!from: anInputStream in: anImportSystem.	^self new initializeWith: anImportSystem importingFrom: anInputStream! !Importer subclass: #CustomerImporter	instanceVariableNames: 'newCustomer newAddress'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!CustomerImporter methodsFor: 'importing' stamp: 'Pablo 7/2/2018 14:02'!importRecord	self extractLineToRecord.	self lineIsCustomer		ifTrue: [ self importNewCustomer ].	self lineIsAddress		ifTrue: [ self importAddress ].	self lineIsUndefinedType		ifTrue: [ self error: self class invalidRecordTypeError ]! !!CustomerImporter methodsFor: 'error checking' stamp: 'Pablo 6/24/2018 16:56'!failOnNoCustomer	newCustomer isNil		ifTrue: [ self error: self class cannotSaveAddressWithoutACustomerError ]! !!CustomerImporter methodsFor: 'error checking' stamp: 'PauloOlveira 6/25/2018 16:44'!failOnNonNumericFieldAddress	record third isAllDigits		ifFalse: [ self error: self class nonNumericAddressRecordFieldsError ].	record fifth isAllDigits		ifFalse: [ self error: self class nonNumericAddressRecordFieldsError ]! !!CustomerImporter methodsFor: 'error checking' stamp: 'Pablo 6/24/2018 16:53'!failIfFieldsCountIsNot: expectedFields With: error	record size == expectedFields		ifFalse: [ self error: error ]! !!CustomerImporter methodsFor: 'parsing' stamp: 'Pablo 6/21/2018 19:54'!lineIsCustomer	^ line beginsWith: 'C'! !!CustomerImporter methodsFor: 'parsing' stamp: 'PauloOlveira 6/25/2018 16:42'!importAddress	self		failIfFieldsCountIsNot: self expectedAddressFieldsCount		With: self class missingAddressRecordFieldsError.	self failOnNoCustomer.	self failOnNonNumericFieldAddress.	newAddress := Address new.	newAddress streetName: record second.	newAddress streetNumber: record third asInteger.	newAddress town: record fourth.	newAddress zipCode: record fifth asInteger.	newAddress province: record sixth.	newCustomer addAddress: newAddress! !!CustomerImporter methodsFor: 'parsing' stamp: 'Pablo 7/2/2018 14:02'!importNewCustomer	self		failIfFieldsCountIsNot: self expectedCustomerFieldsCount		With: self class missingCustomerRecordFieldsError.	newCustomer := Customer new.	newCustomer firstName: record second.	newCustomer lastName: record third.	newCustomer identificationType: record fourth.	newCustomer identificationNumber: record fifth.	importSystem persist: newCustomer! !!CustomerImporter methodsFor: 'parsing' stamp: 'Pablo 6/21/2018 19:59'!extractLineToRecord	record := line substrings: {$,}! !!CustomerImporter methodsFor: 'parsing' stamp: 'Pablo 6/21/2018 20:29'!lineIsAddress	^ line beginsWith: 'A'! !!CustomerImporter methodsFor: 'parsing' stamp: 'Pablo 6/21/2018 21:19'!lineIsUndefinedType	^(self lineIsAddress | self lineIsCustomer) not! !!CustomerImporter methodsFor: 'constants' stamp: 'Pablo 6/24/2018 16:56'!expectedCustomerFieldsCount	^ 5! !!CustomerImporter methodsFor: 'constants' stamp: 'Pablo 6/24/2018 16:55'!expectedAddressFieldsCount	^ 6! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CustomerImporter class	instanceVariableNames: ''!!CustomerImporter class methodsFor: 'error messages' stamp: 'PauloOlveira 6/25/2018 16:25'!nonNumericCustomerRecordFieldsError	^'Numeric field was not numeric en Customer Record'! !!CustomerImporter class methodsFor: 'error messages' stamp: 'PauloOlveira 6/25/2018 16:25'!nonNumericAddressRecordFieldsError	^'Numeric field was not numeric en Address Record'! !!CustomerImporter class methodsFor: 'error messages' stamp: 'Pablo 6/21/2018 21:11'!missingCustomerRecordFieldsError	^'Missing Customer record fields'! !!CustomerImporter class methodsFor: 'error messages' stamp: 'Pablo 6/21/2018 21:11'!missingAddressRecordFieldsError	^'Not enough fields in address records'! !!CustomerImporter class methodsFor: 'error messages' stamp: 'Pablo 6/21/2018 21:08'!cannotSaveAddressWithoutACustomerError	^'Cannot save address if the are no customers yet'! !Environment subclass: #IntegrationEnvironment	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!IntegrationEnvironment class	instanceVariableNames: ''!!IntegrationEnvironment class methodsFor: 'selection' stamp: 'Pablo 6/28/2018 00:13'!isCurrent	^false! !!IntegrationEnvironment class methodsFor: 'system creation' stamp: 'Pablo 6/28/2018 00:05'!createCustomerSystem	^PersistentCustomerSystem new.! !!IntegrationEnvironment class methodsFor: 'system creation' stamp: 'Pablo 7/2/2018 18:30'!createSupplierSystem	^PersistentSupplierSystem  new.! !Object subclass: #Party	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!Party methodsFor: 'importing' stamp: 'Pablo 7/2/2018 10:15'!isIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber	^ self identificationType = anIdentifycationType		and: [ self identificationNumber = anIdentificationNumber ]! !!Party methodsFor: 'addresses' stamp: 'Pablo 7/2/2018 10:15'!addresses	^ addresses! !!Party methodsFor: 'addresses' stamp: 'Pablo 7/2/2018 17:50'!addressAt: aStreetName ifNone: noneClosure 		^self addresses detect: [ :anAddress | anAddress isAt: aStreetName ] ifNone: noneClosure ! !!Party methodsFor: 'addresses' stamp: 'Pablo 7/2/2018 17:50'!numberOfAddresses		^self addresses size! !Party subclass: #Customer	instanceVariableNames: 'id firstName lastName identificationType identificationNumber addresses'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!Customer methodsFor: 'naming' stamp: 'HernanWilkinson 10/28/2016 13:09'!lastName: aLastName 	lastName := aLastName! !!Customer methodsFor: 'naming' stamp: 'Pablo 7/2/2018 17:53'!identificationNumber: aNumber		identificationNumber := aNumber  ! !!Customer methodsFor: 'naming' stamp: 'Pablo 7/2/2018 17:52'!identificationType		^identificationType ! !!Customer methodsFor: 'naming' stamp: 'HernanWilkinson 10/28/2016 13:09'!firstName: aName 	firstName := aName! !!Customer methodsFor: 'naming' stamp: 'Pablo 7/2/2018 17:48'!initialize	addresses := OrderedCollection new.! !!Customer methodsFor: 'naming' stamp: 'Pablo 7/2/2018 17:55'!addresses	^addresses ! !!Customer methodsFor: 'naming' stamp: 'Pablo 7/2/2018 17:52'!identificationType: aType		identificationType := aType ! !!Customer methodsFor: 'naming' stamp: 'HernanWilkinson 10/28/2016 16:15'!firstName		^firstName ! !!Customer methodsFor: 'naming' stamp: 'HernanWilkinson 10/28/2016 16:15'!lastName	^lastName ! !!Customer methodsFor: 'naming' stamp: 'Pablo 7/2/2018 17:53'!identificationNumber		^identificationNumber ! !!Customer methodsFor: 'addresses' stamp: 'Pablo 7/2/2018 17:51'!addAddress: anAddress 	addresses add: anAddress ! !!Customer methodsFor: 'intialization' stamp: 'Pablo 7/2/2018 18:53'!identifiedBy: anIdType numbered: aNumber 	^self 		identificationType: anIdType;		identificationNumber: aNumber.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Customer class	instanceVariableNames: ''!!Customer class methodsFor: 'as yet unclassified' stamp: 'Pablo 7/2/2018 18:52'!newIdentifiedBy: anIdType numbered: aNumber 	^self new identifiedBy: anIdType numbered: aNumber! !CustomerSystem subclass: #PersistentCustomerSystem	instanceVariableNames: 'session'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!PersistentCustomerSystem methodsFor: 'initialization' stamp: 'PauloOlveira 6/27/2018 00:13'!initialize	self initializeSession ! !!PersistentCustomerSystem methodsFor: 'initialization' stamp: 'Pablo 7/2/2018 18:27'!customerClassMapping	^ ClassMapping		withDefaultTableNameFor: Customer		mappingAll:			(Array				with: (EmbededMapping withDefaultFieldNameFor: #firstName)				with: (EmbededMapping withDefaultFieldNameFor: #lastName)				with: (EmbededMapping withDefaultFieldNameFor: #identificationType)				with: (EmbededMapping withDefaultFieldNameFor: #identificationNumber)				with: (OneToManyMapping withDefaultFieldNameFor: #addresses ofType: Address))! !!PersistentCustomerSystem methodsFor: 'initialization' stamp: 'Pablo 7/2/2018 18:27'!initializeSession	session := DataBaseSession		for: (Array with: self addressClassMapping with: self customerClassMapping )! !!PersistentCustomerSystem methodsFor: 'initialization' stamp: 'Pablo 7/2/2018 18:27'!addressClassMapping	^ ClassMapping		withDefaultTableNameFor: Address		mappingAll:			(Array				with: (EmbededMapping withDefaultFieldNameFor: #streetName)				with: (EmbededMapping withDefaultFieldNameFor: #streetNumber)				with: (EmbededMapping withDefaultFieldNameFor: #town)				with: (EmbededMapping withDefaultFieldNameFor: #zipCode)				with: (EmbededMapping withDefaultFieldNameFor: #province))! !!PersistentCustomerSystem methodsFor: 'accessing' stamp: 'PauloOlveira 6/26/2018 23:58'!session	^ session! !!PersistentCustomerSystem methodsFor: 'accessing' stamp: 'PauloOlveira 6/27/2018 00:18'!allCustomers	^ self session selectAllOfType: Customer! !!PersistentCustomerSystem methodsFor: 'accessing' stamp: 'PauloOlveira 6/27/2018 00:51'!customerIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber	| customers |	customers := self session		select: [ :aCustomer | 			aCustomer				isIdentifiedAs: anIdentifycationType				numbered: anIdentificationNumber ]		ofType: Customer.	customers size = 1		ifFalse: [ self error: 'No se encontro el cliente' ].	^ customers anyOne! !!PersistentCustomerSystem methodsFor: 'accessing' stamp: 'PauloOlveira 6/26/2018 23:58'!session: anObject	session := anObject! !!PersistentCustomerSystem methodsFor: 'accessing' stamp: 'PauloOlveira 6/27/2018 00:19'!allAddresses	^ self session selectAllOfType: Address! !!PersistentCustomerSystem methodsFor: 'session handling' stamp: 'Pablo 6/28/2018 00:06'!commit	self session commit! !!PersistentCustomerSystem methodsFor: 'session handling' stamp: 'PauloOlveira 6/27/2018 00:15'!start	self session open! !!PersistentCustomerSystem methodsFor: 'session handling' stamp: 'PauloOlveira 6/27/2018 00:16'!beginTransaction	self session beginTransaction! !!PersistentCustomerSystem methodsFor: 'session handling' stamp: 'Pablo 6/28/2018 00:07'!close	self session close! !!PersistentCustomerSystem methodsFor: 'persistance' stamp: 'Pablo 6/27/2018 23:51'!persist: aCustomer	session persist: aCustomer! !PersistentCustomerSystem subclass: #PersistentSupplierSystem	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!PersistentSupplierSystem methodsFor: 'initialization' stamp: 'Pablo 7/2/2018 18:28'!initializeSession	session := DataBaseSession		for: (Array with: self addressClassMapping with: self customerClassMapping with: self supplierClassMapping)! !!PersistentSupplierSystem methodsFor: 'initialization' stamp: 'Pablo 7/2/2018 18:53'!supplierClassMapping	^ ClassMapping		withDefaultTableNameFor: Supplier		mappingAll:			(Array				with: (EmbededMapping withDefaultFieldNameFor: #name)				with: (EmbededMapping withDefaultFieldNameFor: #identificationType)				with: (EmbededMapping withDefaultFieldNameFor: #identificationNumber)				with: (OneToManyMapping withDefaultFieldNameFor: #addresses ofType: Address)				with: (OneToManyMapping withDefaultFieldNameFor: #customers ofType: Customer))! !!PersistentSupplierSystem methodsFor: 'accessing' stamp: 'Pablo 7/2/2018 18:54'!allSuppliers	^ self session selectAllOfType: Supplier! !!PersistentSupplierSystem methodsFor: 'accessing' stamp: 'Pablo 7/2/2018 18:59'!supplierIdentifiedBy: anIdType numbered: aNumber 	^(self session 		select: [ :supplier| supplier isIdentifiedAs: anIdType numbered: aNumber ]  		ofType: Supplier) first ! !Party subclass: #Supplier	instanceVariableNames: 'id name customers identificationType identificationNumber addresses'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!Supplier methodsFor: 'customers' stamp: 'Pablo 7/2/2018 18:51'!serveCustomerWith: anIdentificationType numbered: aNumber	customers add: (Customer newIdentifiedBy: anIdentificationType numbered: aNumber ) ! !!Supplier methodsFor: 'customers' stamp: 'Pablo 7/2/2018 19:00'!hasCustomerIdentifiedAs: anIdType numbered: aNumber 	^customers anySatisfy: 		[ :customer| customer isIdentifiedAs: anIdType numbered: aNumber ]! !!Supplier methodsFor: 'customers' stamp: 'Pablo 7/2/2018 10:08'!customers	^ customers copy! !!Supplier methodsFor: 'naming' stamp: 'PauloOlveira 7/2/2018 08:51'!name: aName 	name := aName! !!Supplier methodsFor: 'initialization' stamp: 'Pablo 7/2/2018 17:54'!identificationType		^identificationType ! !!Supplier methodsFor: 'initialization' stamp: 'Pablo 7/2/2018 17:54'!identificationType: aType		identificationType := aType ! !!Supplier methodsFor: 'initialization' stamp: 'Pablo 7/2/2018 17:55'!identificationNumber		^identificationNumber  ! !!Supplier methodsFor: 'initialization' stamp: 'Pablo 7/2/2018 17:55'!addresses	^addresses ! !!Supplier methodsFor: 'initialization' stamp: 'Pablo 7/2/2018 17:54'!identificationNumber: aNumber		identificationNumber := aNumber  ! !!Supplier methodsFor: 'initialization' stamp: 'Pablo 7/2/2018 17:48'!initialize	addresses := OrderedCollection new.	customers := OrderedCollection new.! !!Supplier methodsFor: 'addresses' stamp: 'Pablo 7/2/2018 17:51'!addAddress: anAddress 	addresses add: anAddress ! !TestCase subclass: #SupplierImportTest	instanceVariableNames: 'importer customerSystem supplierSystem'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!SupplierImportTest methodsFor: 'tests' stamp: 'Pablo 7/2/2018 12:10'!test01ImportSupplier		(SupplierImporter from: self validTestDataWithoutAddresses in: customerSystem andIn: supplierSystem) import.		self assertImportedSuppliersSizeIsCorrect.	self assertSupplier1WasImportedCorrectly! !!SupplierImportTest methodsFor: 'tests' stamp: 'Pablo 7/2/2018 11:05'!test02FailWhenImportingNewCustomerForNoSupplier		self 		should: [ (SupplierImporter from: self noSupplierTestData in: customerSystem andIn: supplierSystem) import. ] 		raise: Exception - MessageNotUnderstood		withExceptionDo: [ :error|			self assert: error messageText equals: SupplierImporter noSupplierError.			self assert: supplierSystem allSuppliers isEmpty.		].		! !!SupplierImportTest methodsFor: 'tests' stamp: 'Pablo 7/2/2018 12:16'!test04AddressesAreImportedIntoSupplier		| expectedSupplier |	(SupplierImporter from: self validTestDataWithAddresses  in: customerSystem andIn: supplierSystem) import.		self assertImportedSuppliersSizeIsCorrect.	expectedSupplier := supplierSystem supplierIdentifiedBy: 'D' numbered: '123'.	self assert: expectedSupplier customers size equals: 2.	self assert: expectedSupplier addresses size equals: 2.	self assert: (expectedSupplier addresses anySatisfy: [ :address | address isAt: 'San Martin' ]).	self assert: (expectedSupplier addresses anySatisfy: [ :address | address isAt: 'Maipu' ]).! !!SupplierImportTest methodsFor: 'tests' stamp: 'Pablo 7/2/2018 11:05'!test03FailWhenImportingExistingCustomerForNoSupplier		self 		should: [ (SupplierImporter from: self noSupplierForExistingCustomerTestData in: customerSystem andIn: supplierSystem) import. ] 		raise: Exception - MessageNotUnderstood		withExceptionDo: [ :error|			self assert: error messageText equals: SupplierImporter noSupplierError.			self assert: supplierSystem allSuppliers isEmpty.		].		! !!SupplierImportTest methodsFor: 'tests input' stamp: 'Pablo 7/2/2018 11:00'!noSupplierTestData	^ ReadStream on:'NC,Pepe,Sanchez,D,22333444'! !!SupplierImportTest methodsFor: 'tests input' stamp: 'Pablo 7/2/2018 12:10'!validTestDataWithAddresses	^ ReadStream on:'S,Supplier1,D,123NC,Pepe,Sanchez,D,22333444EC,D,5456774A,San Martin,3322,Olivos,1636,BsAsA,Maipu,888,Florida,1122,Buenos Aires'! !!SupplierImportTest methodsFor: 'tests input' stamp: 'Pablo 7/2/2018 12:10'!validTestDataWithoutAddresses	^ ReadStream on:'S,Supplier1,D,123NC,Pepe,Sanchez,D,22333444EC,D,5456774'! !!SupplierImportTest methodsFor: 'tests input' stamp: 'Pablo 7/2/2018 11:06'!noSupplierForExistingCustomerTestData	^ ReadStream on:'EC,D,5456774'! !!SupplierImportTest methodsFor: 'assertions' stamp: 'Pablo 7/2/2018 12:21'!assertSupplier1WasImportedCorrectly	| expectedSupplier |	expectedSupplier := supplierSystem supplierIdentifiedBy: 'D' numbered: '123'.	self assert: expectedSupplier addresses isEmpty.	self assert: expectedSupplier customers size equals: 2.	self assert: (expectedSupplier hasCustomerIdentifiedAs: 'D' numbered: '22333444').	self assert: (expectedSupplier hasCustomerIdentifiedAs: 'D' numbered: '5456774').! !!SupplierImportTest methodsFor: 'assertions' stamp: 'Pablo 7/2/2018 09:55'!assertImportedSuppliersSizeIsCorrect	self assert: supplierSystem allSuppliers size equals: 1	! !!SupplierImportTest methodsFor: 'setup-teardown' stamp: 'PauloOlveira 7/2/2018 09:23'!setUp	customerSystem := (Environment currentFor: self) createCustomerSystem.	customerSystem start.	customerSystem beginTransaction.		supplierSystem := (Environment currentFor: self) createSupplierSystem.		supplierSystem start.		supplierSystem beginTransaction! !!SupplierImportTest methodsFor: 'setup-teardown' stamp: 'PauloOlveira 7/2/2018 09:24'!tearDown	customerSystem commit.	customerSystem close.		supplierSystem commit.	supplierSystem close! !CustomerImporter subclass: #SupplierImporter	instanceVariableNames: 'newSupplier supplierSystem'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!SupplierImporter methodsFor: 'intialization' stamp: 'Pablo 7/2/2018 10:35'!initializeWith: aCustomerSystem and: aSupplierSystem importingFrom: aReadStream 	importSystem := aCustomerSystem.	supplierSystem := aSupplierSystem.	inputStream := aReadStream. ! !!SupplierImporter methodsFor: 'parsing' stamp: 'PauloOlveira 7/2/2018 08:53'!lineIsExistentCustomer	^ line beginsWith: 'EC'! !!SupplierImporter methodsFor: 'parsing' stamp: 'PauloOlveira 7/2/2018 08:42'!lineIsSupplier	^ line beginsWith: 'S'! !!SupplierImporter methodsFor: 'parsing' stamp: 'PauloOlveira 7/2/2018 09:08'!lineIsUndefinedType	^(self lineIsAddress | self lineIsExistentCustomer | self lineIsNonExistentCustomer | self lineIsSupplier) not! !!SupplierImporter methodsFor: 'parsing' stamp: 'PauloOlveira 7/2/2018 08:52'!lineIsNonExistentCustomer	^ line beginsWith: 'NC' ! !!SupplierImporter methodsFor: 'importing' stamp: 'Pablo 7/2/2018 11:04'!importExistentCustomer	newSupplier ifNil: [ self error: self class noSupplierError ].	newSupplier serveCustomerWith: record second numbered: record third. ! !!SupplierImporter methodsFor: 'importing' stamp: 'Pablo 7/2/2018 12:01'!importSupplier	self		failIfFieldsCountIsNot: self expectedSupplierFieldsCount		With: self class missingSupplierRecordFieldsError.	newSupplier := Supplier new.	newSupplier name: record second.	newSupplier identificationType: record third.	newSupplier identificationNumber: record fourth.	supplierSystem persist: newSupplier! !!SupplierImporter methodsFor: 'importing' stamp: 'Pablo 7/2/2018 12:16'!importAddressInto: aParty	self		failIfFieldsCountIsNot: self expectedAddressFieldsCount		With: self class missingAddressRecordFieldsError.	self failOnNoCustomer.	self failOnNonNumericFieldAddress.	newAddress := Address new.	newAddress streetName: record second.	newAddress streetNumber: record third asInteger.	newAddress town: record fourth.	newAddress zipCode: record fifth asInteger.	newAddress province: record sixth.	aParty addAddress: newAddress! !!SupplierImporter methodsFor: 'importing' stamp: 'Pablo 7/2/2018 14:06'!importNewCustomer	newSupplier ifNil: [ self error: self class noSupplierError ].	super importNewCustomer.	newSupplier serveCustomerWith: record fourth numbered: record fifth. 	! !!SupplierImporter methodsFor: 'importing' stamp: 'Pablo 7/2/2018 14:04'!importRecord	self extractLineToRecord.	self lineIsSupplier		ifTrue: [ self importSupplier ].	self lineIsNonExistentCustomer		ifTrue: [ self importNewCustomer. ].	self lineIsExistentCustomer		ifTrue: [ self importExistentCustomer ].	self lineIsAddress		ifTrue: [ self importAddressInto: newSupplier ].	self lineIsUndefinedType		ifTrue: [ self error: self class invalidRecordTypeError ]! !!SupplierImporter methodsFor: 'constants' stamp: 'PauloOlveira 7/2/2018 08:49'!expectedSupplierFieldsCount	^ 4! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SupplierImporter class	instanceVariableNames: ''!!SupplierImporter class methodsFor: 'instance creation' stamp: 'Pablo 7/2/2018 11:04'!noSupplierError	^'Cannot add Customer or Addresses for non-existing supplier'! !!SupplierImporter class methodsFor: 'instance creation' stamp: 'PauloOlveira 7/2/2018 09:26'!from: aReadStream in: aCustomerSystem andIn: aSupplierSystem 	^self new initializeWith: aCustomerSystem and: aSupplierSystem importingFrom: aReadStream! !!SupplierImporter class methodsFor: 'instance creation' stamp: 'PauloOlveira 7/2/2018 08:50'!missingSupplierRecordFieldsError	^'Not enough fields in supplier records'! !Environment subclass: #TestEnvironment	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!TestEnvironment class	instanceVariableNames: ''!!TestEnvironment class methodsFor: 'system creation' stamp: 'Pablo 6/28/2018 00:04'!createCustomerSystem	^TransientCustomerSystem new.! !!TestEnvironment class methodsFor: 'system creation' stamp: 'PauloOlveira 7/2/2018 16:39'!createSupplierSystem	^TransientSupplierSystem new.! !!TestEnvironment class methodsFor: 'selection' stamp: 'Pablo 6/28/2018 00:13'!isCurrent	^true! !CustomerSystem subclass: #TransientCustomerSystem	instanceVariableNames: 'customers'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!TransientCustomerSystem methodsFor: 'accessing' stamp: 'Pablo 6/27/2018 22:55'!allAddresses	^customers inject: OrderedCollection new into: [ :addresses :customer |		addresses addAll: customer addresses copy.		addresses] ! !!TransientCustomerSystem methodsFor: 'accessing' stamp: 'PauloOlveira 6/27/2018 00:42'!customerIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber	^customers detect: [ :aCustomer |aCustomer isIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber ]! !!TransientCustomerSystem methodsFor: 'accessing' stamp: 'PauloOlveira 6/27/2018 00:37'!allCustomers	^customers copy! !!TransientCustomerSystem methodsFor: 'persistance' stamp: 'Pablo 6/27/2018 23:51'!persist: aCustomer 	customers add: aCustomer! !!TransientCustomerSystem methodsFor: 'initialization' stamp: 'Pablo 6/27/2018 23:50'!initialize	customers := OrderedCollection new.! !!TransientCustomerSystem methodsFor: 'session handling' stamp: 'Pablo 6/27/2018 22:51'!commit! !!TransientCustomerSystem methodsFor: 'session handling' stamp: 'Pablo 6/27/2018 22:51'!close! !!TransientCustomerSystem methodsFor: 'session handling' stamp: 'PauloOlveira 6/27/2018 00:46'!beginTransaction! !!TransientCustomerSystem methodsFor: 'session handling' stamp: 'Pablo 6/27/2018 23:50'!start! !TransientCustomerSystem subclass: #TransientSupplierSystem	instanceVariableNames: 'suppliers'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!TransientSupplierSystem methodsFor: 'initialization' stamp: 'Pablo 7/2/2018 09:58'!initialize	suppliers := OrderedCollection new.! !!TransientSupplierSystem methodsFor: 'initialization' stamp: 'Pablo 7/2/2018 09:59'!persist: aSupplierOrCustomer	(aSupplierOrCustomer isKindOf: Supplier) 		ifTrue: [ suppliers add: aSupplierOrCustomer ]		ifFalse: [ super persist: aSupplierOrCustomer ]	! !!TransientSupplierSystem methodsFor: 'accessing' stamp: 'Pablo 7/2/2018 10:00'!allSuppliers	^suppliers copy.! !!TransientSupplierSystem methodsFor: 'accessing' stamp: 'Pablo 7/2/2018 10:04'!supplierIdentifiedBy: anIdentificationType numbered: aNumber	^suppliers detect: [ :supplier| supplier isIdentifiedAs: anIdentificationType numbered: aNumber ] 	! !'From Pharo6.0 of 13 May 2016 [Latest update: #60539] on 2 July 2018 at 7:01:45.267716 pm'!!String methodsFor: '*IS1-CustomerImport' stamp: 'HernanWilkinson 10/31/2016 23:57'!asPlural		^self last = $s 		ifTrue: [ self, 'es' ]		ifFalse: [ self, 's' ]! !'From Pharo6.0 of 13 May 2016 [Latest update: #60539] on 2 July 2018 at 7:01:45.268675 pm'!!Object methodsFor: '*IS1-CustomerImport' stamp: 'HernanWilkinson 10/31/2016 19:27'!toDo: aString 	! !